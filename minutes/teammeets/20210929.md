Arbor Team Meeting 2021 09 29
=============================

Meeting link: https://conf.dfn.de/webapp/#/?conference=979170431&pin=0000
Collaborative editing: https://demo.hedgedoc.org/new
Turn Issues and PRs you want to discuss into agenda items.

Presence: BH, TH, AK, 

## MSc/PhD project: high level netwerk description

* High level network descriptions: https://github.com/arbor-sim/arbor/issues/418
    * TH: add work desc in the ticket
    * BH: make proposal
* possibly https://github.com/arbor-sim/arbor/issues/1680 ?
* At FZJ:
    * Guest student program / summer student at FZJ = 6/10 weeks.
        * computational focussed.
    * Chinese Scholarship Council call
* Have more proposals
    * select a bunch of issues?
        * AEP/enhancements labels in Issues
            * BH: compile 
    * make list of projects, ask Sandra/Wouter for theirs?
    * Idea: Overhaul Python testing
    * Idea: Cleaning up Python interface
        * What needs to be cleaned?
        * Software design perspective.

## Defaults
* How many threads by default?
    * Earlier discussion, PR rejected. This set it for both C++ and Python
    * Requested: `arbor.context(jezus_take_the_wheel=True)`
        * Maybe:
            * arbor.full_local_cpu_context()
            * arbor.full_local_gpu_context()
            * arbor.context(use_full_local_cpu=True)
            * arbor.context(threads='all')
                * BH: make ticket.
    * In C++, there's a separate arbenv lib containing such utils
    * NA proposal:
    ```
    # Get a context with the default MPI comm if MPI
    # is enabled, a task system with max number of
    # threads available on the node, and default GPU
    # id if enabled and available.
    default_resources = arbor.default_resources() 
    context = arbor.context(default_resources)
    ```
    (Actually [NA] is not sure this is the way to go.  It's not really the responsibility of the `arbor` library. If we're gonna expose some helpful calls in arbor, they should probably be something like `arbor.get_gpu_id()`, `arbor.get_mpi_comm()` and `arbor.get_num_threads()`)
* It's not the first time sysadmin and end-user (Pythonic) preferences/expectations clash. The Python API already has Pythonic things in it, this is not a bad thing.
    * BH: Maybe just for the `pip` wheels?

## Partners

* BH: Today: 1:1 w/ Mario. No agenda. Well, I'll propose a ARBORIO checkin, but he has something to say/ask clearly.
* NA/TH helping Robin with his model. He's seeing bad performance compared to NEURON (10x) slower at the moment. Could be a number of factors affecting the performance or comparison: 
  * Probably not:
    * Too much sampling.
    * Different dt.
    * Different discretization.
  * Suboptimal node configuration (Robin's using 1 MPI node per physical (logical?) core). 

  We're trying to get the profile generated by arbor. Profiling can't be enabled from externally loaded catalogues at the moment. 
  
* Microsoft Azure meeting went well. Will get back to MS with possible concrete project(s)/workshop/hackathon ideas.
  
## Performance: multithreading vs MPI
* Testing the performance of a variation of the `ring` example with 10000 cells with 10000 synapses connected with non-zero weights on 1 node of Piz Daint multicore partition. (Will formalize this more). 
 ```
 2  ranks 36 threads = 52.9 s
 4  ranks 18 threads = 37.2 s
 18 ranks 4 threads  = 31.8 s
 36 ranks 2 threads  = 35.4 s
 72 ranks 1 thread   = 43.9 s
 ```
 ```
  2  ranks 18 threads = 58.7 s
  4  ranks 9 threads  = 61.9 s
  18 ranks 2 threads  = 46.3 s
  36 ranks 1 threads  = 43.3 s
  ```

## Gap Junction mechanisms
https://github.com/arbor-sim/arbor/pull/1682
* What happens if we connect multiple gap-junction  connections to the same gap-junction-mechanism lid? 
    * At that lid, there will be multiple instances of the mechanism. This is so that the `init`, `current_update` and `state_update` callbacks are evaluated once per `dt` per gap-junction connection. This is in contrast to synapse mechanisms, where if there are multiple connections ending at the same synapse lid, there's only one instance of that synapse mechanism, so that the `init`, `current_update` and `state_update` callbacks are evaluated only once per `dt` for that lid, but the `net_receive` callback is evaluated for each event on that synapse. However, this does create an analogue with synapses in that the `node_index` of both gap-junction mechanisms and synapse mechansism can have repeated CV-indices (albeit for different reasons). This means that a reduction is needed on GPU for current/conductance contirbutions. 
* What happens if we don't connect any gap-junction  connections to a given gap-junction-mechanism lid? 
    * No mechanism is inserted on that lid.

## Calendar and meetings

* The shared calendar:
    * Meetings where certain team members are expected to participate should be sent out as invites. This is possible through framagenda, for example the `Microsoft <-> FZJ/Arbor exchange` had both internal and external attendees listed. We should do this for the Arbor weekly meeting.
    * All meetings should have a brief description.
* The web-conferencing tool:
    * The meeting room being independent from any single host shouldn't be a hard requirement. Tools such as zoom and google meet work well, and I think they should be out first choice. [NA] happy to volunteer personal zoom room.

## Many open PRs

* Let's go over them and assign?
    * https://github.com/arbor-sim/arbor/pulls


## Other Issues & PRs

* https://github.com/orgs/arbor-sim/projects/3
* https://github.com/arbor-sim/arbor/pulls

## End

TODO and Decisions
------------------

Next time
---------

